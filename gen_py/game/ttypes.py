#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class UnitType:
  """
  Types of units. Unit strengths and weaknesses are weather-dependent.
  """
  TYPE0 = 0
  TYPE1 = 1
  TYPE2 = 2
  BASE = 3

  _VALUES_TO_NAMES = {
    0: "TYPE0",
    1: "TYPE1",
    2: "TYPE2",
    3: "BASE",
  }

  _NAMES_TO_VALUES = {
    "TYPE0": 0,
    "TYPE1": 1,
    "TYPE2": 2,
    "BASE": 3,
  }

class WeatherCond:
  """
  Weather conditions.

  Normal is where 0 beats 1, 1 beats 2 and 2 beats 0.

  Reversed is the reverse of normal.

  Dominate is where 0 beats both 1 and 2

  Weak is where 0 is weak to both 1 and 2
  """
  NORMAL = 0
  REVERSED = 1
  DOMINATE = 2
  WEAK = 3

  _VALUES_TO_NAMES = {
    0: "NORMAL",
    1: "REVERSED",
    2: "DOMINATE",
    3: "WEAK",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 0,
    "REVERSED": 1,
    "DOMINATE": 2,
    "WEAK": 3,
  }

class TileType:
  """
  ~The type of tiles~

  Plains -Readily traversable, pretty much "normal ground"

  Hills  -Limits movement, Once you travel over a hill you cant move any further

  Oceans -Impassable, Similar to lava in the game "the floor is lava"
  """
  PLAINS = 0
  HILL = 1
  OCEAN = 2

  _VALUES_TO_NAMES = {
    0: "PLAINS",
    1: "HILL",
    2: "OCEAN",
  }

  _NAMES_TO_VALUES = {
    "PLAINS": 0,
    "HILL": 1,
    "OCEAN": 2,
  }

class OpType:
  """
  The four operations possible. Move, attack and buy are explained alongside
  their arguments (MoveOp, AttackOp and BuyOp). Check weather is a unique
  operation that consumes half the maximum queue length. It updates the
  WeatherState in your own UserState.
  """
  MOVE = 0
  ATTACK = 1
  BUY = 2
  CHECK_WEATHER = 3

  _VALUES_TO_NAMES = {
    0: "MOVE",
    1: "ATTACK",
    2: "BUY",
    3: "CHECK_WEATHER",
  }

  _NAMES_TO_VALUES = {
    "MOVE": 0,
    "ATTACK": 1,
    "BUY": 2,
    "CHECK_WEATHER": 3,
  }


class Pos:
  """
  How position is mapped

  Attributes:
   - y
   - x
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'y', None, None, ), # 1
    (2, TType.I32, 'x', None, None, ), # 2
  )

  def __init__(self, y=None, x=None,):
    self.y = y
    self.x = x

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.y = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.x = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Pos')
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.I32, 1)
      oprot.writeI32(self.y)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.I32, 2)
      oprot.writeI32(self.x)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Unit:
  """
  Represents a live unit.

  There is at least one case where we might want to talk about a unit by
  itself without a position: when referring to an enemy to attack, we may not
  want to restrict ourselves to an attack on a unit in one position

  Attributes:
   - id: A unique id that lets us identify units.
   - type
   - health
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.I32, 'health', None, None, ), # 3
  )

  def __init__(self, id=None, type=None, health=None,):
    self.id = id
    self.type = type
    self.health = health

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.health = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Unit')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.health is not None:
      oprot.writeFieldBegin('health', TType.I32, 3)
      oprot.writeI32(self.health)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnitPos:
  """
  A unit that is alive and positioned somewhere on the map.

  Attributes:
   - unit
   - pos
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'unit', (Unit, Unit.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'pos', (Pos, Pos.thrift_spec), None, ), # 2
  )

  def __init__(self, unit=None, pos=None,):
    self.unit = unit
    self.pos = pos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.unit = Unit()
          self.unit.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.pos = Pos()
          self.pos.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnitPos')
    if self.unit is not None:
      oprot.writeFieldBegin('unit', TType.STRUCT, 1)
      self.unit.write(oprot)
      oprot.writeFieldEnd()
    if self.pos is not None:
      oprot.writeFieldBegin('pos', TType.STRUCT, 2)
      self.pos.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WorldState:
  """
  Wraps together World State, state which is associated with the whole world
  and concerns both players.

  Attributes:
   - units: A list of maps, where each map corresponds to one player's units.
  worldstate.units[pid] will get 	your own units and units[1-pid] will get your
  opponents.  The maps are from the unit id to the unit itself (including its
  position and health in the UnitPos struct).
   - bases: Similarly, the bases for both players. These are not present in the units maps.
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'units', (TType.MAP,(TType.I64,None,TType.STRUCT,(UnitPos, UnitPos.thrift_spec))), None, ), # 1
    (2, TType.LIST, 'bases', (TType.STRUCT,(UnitPos, UnitPos.thrift_spec)), None, ), # 2
  )

  def __init__(self, units=None, bases=None,):
    self.units = units
    self.bases = bases

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.units = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = {}
            (_ktype7, _vtype8, _size6 ) = iprot.readMapBegin() 
            for _i10 in xrange(_size6):
              _key11 = iprot.readI64();
              _val12 = UnitPos()
              _val12.read(iprot)
              _elem5[_key11] = _val12
            iprot.readMapEnd()
            self.units.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.bases = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = UnitPos()
            _elem18.read(iprot)
            self.bases.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WorldState')
    if self.units is not None:
      oprot.writeFieldBegin('units', TType.LIST, 1)
      oprot.writeListBegin(TType.MAP, len(self.units))
      for iter19 in self.units:
        oprot.writeMapBegin(TType.I64, TType.STRUCT, len(iter19))
        for kiter20,viter21 in iter19.items():
          oprot.writeI64(kiter20)
          viter21.write(oprot)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.bases is not None:
      oprot.writeFieldBegin('bases', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.bases))
      for iter22 in self.bases:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WeatherState:
  """
  Represents a view of the weather. The turn tells you how out of date it is.
  Weather conditions are guaranteed to stay constant for at least 3 turns.

  Attributes:
   - condition
   - turn
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'condition', None, None, ), # 1
    (2, TType.I32, 'turn', None, None, ), # 2
  )

  def __init__(self, condition=None, turn=None,):
    self.condition = condition
    self.turn = turn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.condition = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.turn = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WeatherState')
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.I32, 1)
      oprot.writeI32(self.condition)
      oprot.writeFieldEnd()
    if self.turn is not None:
      oprot.writeFieldBegin('turn', TType.I32, 2)
      oprot.writeI32(self.turn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserState:
  """
  Captures user-specific state; this is stuff you see about yourself but not
  about the opponent. Includes redundant info about the last turn that might be
  useful; how many ops were valid and how many were invalid. Sum of these two
  is length of submitted queue and queueLen = maxQueueLen - 0.5 *
  lastInvalidOps.

  Attributes:
   - queueLen: the queue length for this turn
   - lastValidOps
   - lastInvalidOps
   - gold
   - weather: This is your view of the weather. Depending on what you do, it could be
  more or less up-to-date than your opponents.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'queueLen', None, None, ), # 1
    (2, TType.I32, 'lastValidOps', None, None, ), # 2
    (3, TType.I32, 'lastInvalidOps', None, None, ), # 3
    (4, TType.I32, 'gold', None, None, ), # 4
    (5, TType.STRUCT, 'weather', (WeatherState, WeatherState.thrift_spec), None, ), # 5
  )

  def __init__(self, queueLen=None, lastValidOps=None, lastInvalidOps=None, gold=None, weather=None,):
    self.queueLen = queueLen
    self.lastValidOps = lastValidOps
    self.lastInvalidOps = lastInvalidOps
    self.gold = gold
    self.weather = weather

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.queueLen = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.lastValidOps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.lastInvalidOps = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.gold = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.weather = WeatherState()
          self.weather.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserState')
    if self.queueLen is not None:
      oprot.writeFieldBegin('queueLen', TType.I32, 1)
      oprot.writeI32(self.queueLen)
      oprot.writeFieldEnd()
    if self.lastValidOps is not None:
      oprot.writeFieldBegin('lastValidOps', TType.I32, 2)
      oprot.writeI32(self.lastValidOps)
      oprot.writeFieldEnd()
    if self.lastInvalidOps is not None:
      oprot.writeFieldBegin('lastInvalidOps', TType.I32, 3)
      oprot.writeI32(self.lastInvalidOps)
      oprot.writeFieldEnd()
    if self.gold is not None:
      oprot.writeFieldBegin('gold', TType.I32, 4)
      oprot.writeI32(self.gold)
      oprot.writeFieldEnd()
    if self.weather is not None:
      oprot.writeFieldBegin('weather', TType.STRUCT, 5)
      self.weather.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class State:
  """
  A wrapper for all the state needed between turns. Both players receieve the
  same state, except for the user field, which has user-specific state.

  Attributes:
   - world
   - turnNum
   - user
   - hasLost: Tells you who has lost so far.
   - itsOn: If it's on, you should keep playing.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'world', (WorldState, WorldState.thrift_spec), None, ), # 1
    (2, TType.I32, 'turnNum', None, None, ), # 2
    (3, TType.STRUCT, 'user', (UserState, UserState.thrift_spec), None, ), # 3
    (4, TType.LIST, 'hasLost', (TType.BOOL,None), None, ), # 4
    (5, TType.BOOL, 'itsOn', None, None, ), # 5
  )

  def __init__(self, world=None, turnNum=None, user=None, hasLost=None, itsOn=None,):
    self.world = world
    self.turnNum = turnNum
    self.user = user
    self.hasLost = hasLost
    self.itsOn = itsOn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.world = WorldState()
          self.world.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.turnNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.user = UserState()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.hasLost = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readBool();
            self.hasLost.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.itsOn = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('State')
    if self.world is not None:
      oprot.writeFieldBegin('world', TType.STRUCT, 1)
      self.world.write(oprot)
      oprot.writeFieldEnd()
    if self.turnNum is not None:
      oprot.writeFieldBegin('turnNum', TType.I32, 2)
      oprot.writeI32(self.turnNum)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 3)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    if self.hasLost is not None:
      oprot.writeFieldBegin('hasLost', TType.LIST, 4)
      oprot.writeListBegin(TType.BOOL, len(self.hasLost))
      for iter29 in self.hasLost:
        oprot.writeBool(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.itsOn is not None:
      oprot.writeFieldBegin('itsOn', TType.BOOL, 5)
      oprot.writeBool(self.itsOn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GameMap:
  """
  Attributes:
   - tiles
   - occupied: Units cannot stack at all, so use this array to avoid submitting move
  operations that fail since someone is already there.
   - height: the first dimension of tiles
   - width: the second dimension of tiles
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tiles', (TType.LIST,(TType.I32,None)), None, ), # 1
    (2, TType.LIST, 'occupied', (TType.LIST,(TType.BOOL,None)), None, ), # 2
    (3, TType.I32, 'height', None, None, ), # 3
    (4, TType.I32, 'width', None, None, ), # 4
  )

  def __init__(self, tiles=None, occupied=None, height=None, width=None,):
    self.tiles = tiles
    self.occupied = occupied
    self.height = height
    self.width = width

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tiles = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = []
            (_etype39, _size36) = iprot.readListBegin()
            for _i40 in xrange(_size36):
              _elem41 = iprot.readI32();
              _elem35.append(_elem41)
            iprot.readListEnd()
            self.tiles.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.occupied = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = []
            (_etype51, _size48) = iprot.readListBegin()
            for _i52 in xrange(_size48):
              _elem53 = iprot.readBool();
              _elem47.append(_elem53)
            iprot.readListEnd()
            self.occupied.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.height = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.width = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GameMap')
    if self.tiles is not None:
      oprot.writeFieldBegin('tiles', TType.LIST, 1)
      oprot.writeListBegin(TType.LIST, len(self.tiles))
      for iter54 in self.tiles:
        oprot.writeListBegin(TType.I32, len(iter54))
        for iter55 in iter54:
          oprot.writeI32(iter55)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.occupied is not None:
      oprot.writeFieldBegin('occupied', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.occupied))
      for iter56 in self.occupied:
        oprot.writeListBegin(TType.BOOL, len(iter56))
        for iter57 in iter56:
          oprot.writeBool(iter57)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.I32, 3)
      oprot.writeI32(self.height)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I32, 4)
      oprot.writeI32(self.width)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InitialGame:
  """
  Attributes:
   - tok: needed to authenticate all future operations
   - state
   - pid: player id; will be 0 or 1
   - gameMap: the game map will only be given once in this struct
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'tok', None, None, ), # 1
    (2, TType.STRUCT, 'state', (State, State.thrift_spec), None, ), # 2
    (3, TType.I32, 'pid', None, None, ), # 3
    (4, TType.STRUCT, 'gameMap', (GameMap, GameMap.thrift_spec), None, ), # 4
  )

  def __init__(self, tok=None, state=None, pid=None, gameMap=None,):
    self.tok = tok
    self.state = state
    self.pid = pid
    self.gameMap = gameMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.tok = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.state = State()
          self.state.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.pid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.gameMap = GameMap()
          self.gameMap.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InitialGame')
    if self.tok is not None:
      oprot.writeFieldBegin('tok', TType.I64, 1)
      oprot.writeI64(self.tok)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRUCT, 2)
      self.state.write(oprot)
      oprot.writeFieldEnd()
    if self.pid is not None:
      oprot.writeFieldBegin('pid', TType.I32, 3)
      oprot.writeI32(self.pid)
      oprot.writeFieldEnd()
    if self.gameMap is not None:
      oprot.writeFieldBegin('gameMap', TType.STRUCT, 4)
      self.gameMap.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MoveOp:
  """
  ~Move unit to location~

  <Legal moves are based on terrain>

  Can move across up to 2 plains

  Can move to an adjacent hill

  Oceans are impassible

  All distances are Manhattan distance, abs(difference in x) + abs(difference in y)

  Failures:

  would fail if unit does not exist or if destination is occupied (by anybody,
  or a base)

  Attributes:
   - unit
   - destination
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'unit', (Unit, Unit.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'destination', (Pos, Pos.thrift_spec), None, ), # 2
  )

  def __init__(self, unit=None, destination=None,):
    self.unit = unit
    self.destination = destination

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.unit = Unit()
          self.unit.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.destination = Pos()
          self.destination.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MoveOp')
    if self.unit is not None:
      oprot.writeFieldBegin('unit', TType.STRUCT, 1)
      self.unit.write(oprot)
      oprot.writeFieldEnd()
    if self.destination is not None:
      oprot.writeFieldBegin('destination', TType.STRUCT, 2)
      self.destination.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AttackOp:
  """
  ~Attack a unit~

  Attacker inflicts damange to enemy based on their types

  Failures:

  If attacker or enemy is dead, or if enemy is now out-of-range (attack radius
  is 1)

  Attributes:
   - attacker
   - enemy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'attacker', (Unit, Unit.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'enemy', (Unit, Unit.thrift_spec), None, ), # 2
  )

  def __init__(self, attacker=None, enemy=None,):
    self.attacker = attacker
    self.enemy = enemy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.attacker = Unit()
          self.attacker.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.enemy = Unit()
          self.enemy.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AttackOp')
    if self.attacker is not None:
      oprot.writeFieldBegin('attacker', TType.STRUCT, 1)
      self.attacker.write(oprot)
      oprot.writeFieldEnd()
    if self.enemy is not None:
      oprot.writeFieldBegin('enemy', TType.STRUCT, 2)
      self.enemy.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BuyOp:
  """
  ~Buy a unit~

  Specify what type unit you want and where it should spawn

  Can spawn within radius 2 of base

  <Failures>

  Pos is too far away

  Don't have enough money

  Attributes:
   - type
   - startPos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'startPos', (Pos, Pos.thrift_spec), None, ), # 2
  )

  def __init__(self, type=None, startPos=None,):
    self.type = type
    self.startPos = startPos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.startPos = Pos()
          self.startPos.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BuyOp')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.startPos is not None:
      oprot.writeFieldBegin('startPos', TType.STRUCT, 2)
      self.startPos.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Op:
  """
  Operations
  It's nice to have a unified, abstract "operation" that can be any operation
  because queueing works on operations generically, we need to have lists of
  operations, and clients may do sophisticated (or maybe necessary) things like
  their own queueing, prioritizing a bunch of operations, or things we didn't think of.

  However, it means we have to encode operations. The OpType specifies what
  this operation is; the other fields are the arguments. Only the set of
  arguments relevant to the type will be read.

  Attributes:
   - type
   - move
   - attack
   - buy
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'move', (MoveOp, MoveOp.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'attack', (AttackOp, AttackOp.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'buy', (BuyOp, BuyOp.thrift_spec), None, ), # 4
  )

  def __init__(self, type=None, move=None, attack=None, buy=None,):
    self.type = type
    self.move = move
    self.attack = attack
    self.buy = buy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.move = MoveOp()
          self.move.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.attack = AttackOp()
          self.attack.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.buy = BuyOp()
          self.buy.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Op')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.move is not None:
      oprot.writeFieldBegin('move', TType.STRUCT, 2)
      self.move.write(oprot)
      oprot.writeFieldEnd()
    if self.attack is not None:
      oprot.writeFieldBegin('attack', TType.STRUCT, 3)
      self.attack.write(oprot)
      oprot.writeFieldEnd()
    if self.buy is not None:
      oprot.writeFieldBegin('buy', TType.STRUCT, 4)
      self.buy.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
