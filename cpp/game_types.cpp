/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "game_types.h"

#include <algorithm>

namespace pulsegame {

int _kUnitTypeValues[] = {
  UnitType::TYPE0,
  UnitType::TYPE1,
  UnitType::TYPE2,
  UnitType::BASE
};
const char* _kUnitTypeNames[] = {
  "TYPE0",
  "TYPE1",
  "TYPE2",
  "BASE"
};
const std::map<int, const char*> _UnitType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kUnitTypeValues, _kUnitTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kWeatherCondValues[] = {
  WeatherCond::NORMAL,
  WeatherCond::REVERSED,
  WeatherCond::DOMINATE,
  WeatherCond::WEAK
};
const char* _kWeatherCondNames[] = {
  "NORMAL",
  "REVERSED",
  "DOMINATE",
  "WEAK"
};
const std::map<int, const char*> _WeatherCond_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kWeatherCondValues, _kWeatherCondNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTileTypeValues[] = {
  TileType::PLAINS,
  TileType::HILL,
  TileType::OCEAN
};
const char* _kTileTypeNames[] = {
  "PLAINS",
  "HILL",
  "OCEAN"
};
const std::map<int, const char*> _TileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTileTypeValues, _kTileTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOpTypeValues[] = {
  OpType::MOVE,
  OpType::ATTACK,
  OpType::BUY,
  OpType::CHECK_WEATHER
};
const char* _kOpTypeNames[] = {
  "MOVE",
  "ATTACK",
  "BUY",
  "CHECK_WEATHER"
};
const std::map<int, const char*> _OpType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kOpTypeValues, _kOpTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Pos::ascii_fingerprint = "C1241AF5AA92C586B664FD41DC97C576";
const uint8_t Pos::binary_fingerprint[16] = {0xC1,0x24,0x1A,0xF5,0xAA,0x92,0xC5,0x86,0xB6,0x64,0xFD,0x41,0xDC,0x97,0xC5,0x76};

uint32_t Pos::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Pos");

  if (this->__isset.y) {
    xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->y);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.x) {
    xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->x);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pos &a, Pos &b) {
  using ::std::swap;
  swap(a.y, b.y);
  swap(a.x, b.x);
  swap(a.__isset, b.__isset);
}

const char* Unit::ascii_fingerprint = "8C8858E5046ACCC78C7CED2E3D90DB5D";
const uint8_t Unit::binary_fingerprint[16] = {0x8C,0x88,0x58,0xE5,0x04,0x6A,0xCC,0xC7,0x8C,0x7C,0xED,0x2E,0x3D,0x90,0xDB,0x5D};

uint32_t Unit::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (UnitType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->health);
          this->__isset.health = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Unit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Unit");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.health) {
    xfer += oprot->writeFieldBegin("health", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->health);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Unit &a, Unit &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.health, b.health);
  swap(a.__isset, b.__isset);
}

const char* UnitPos::ascii_fingerprint = "6E2635070F69FED69A7EF528C76781C7";
const uint8_t UnitPos::binary_fingerprint[16] = {0x6E,0x26,0x35,0x07,0x0F,0x69,0xFE,0xD6,0x9A,0x7E,0xF5,0x28,0xC7,0x67,0x81,0xC7};

uint32_t UnitPos::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unit.read(iprot);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnitPos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnitPos");

  if (this->__isset.unit) {
    xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->unit.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->pos.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnitPos &a, UnitPos &b) {
  using ::std::swap;
  swap(a.unit, b.unit);
  swap(a.pos, b.pos);
  swap(a.__isset, b.__isset);
}

const char* WorldState::ascii_fingerprint = "9B5F640C1730D10D7741E9F291E1A7C9";
const uint8_t WorldState::binary_fingerprint[16] = {0x9B,0x5F,0x64,0x0C,0x17,0x30,0xD1,0x0D,0x77,0x41,0xE9,0xF2,0x91,0xE1,0xA7,0xC9};

uint32_t WorldState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->units.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->units.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              {
                this->units[_i5].clear();
                uint32_t _size6;
                ::apache::thrift::protocol::TType _ktype7;
                ::apache::thrift::protocol::TType _vtype8;
                xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
                uint32_t _i10;
                for (_i10 = 0; _i10 < _size6; ++_i10)
                {
                  int64_t _key11;
                  xfer += iprot->readI64(_key11);
                  UnitPos& _val12 = this->units[_i5][_key11];
                  xfer += _val12.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.units = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bases.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->bases.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->bases[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bases = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WorldState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WorldState");

  if (this->__isset.units) {
    xfer += oprot->writeFieldBegin("units", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->units.size()));
      std::vector<std::map<int64_t, UnitPos> > ::const_iterator _iter18;
      for (_iter18 = this->units.begin(); _iter18 != this->units.end(); ++_iter18)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter18).size()));
          std::map<int64_t, UnitPos> ::const_iterator _iter19;
          for (_iter19 = (*_iter18).begin(); _iter19 != (*_iter18).end(); ++_iter19)
          {
            xfer += oprot->writeI64(_iter19->first);
            xfer += _iter19->second.write(oprot);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bases) {
    xfer += oprot->writeFieldBegin("bases", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bases.size()));
      std::vector<UnitPos> ::const_iterator _iter20;
      for (_iter20 = this->bases.begin(); _iter20 != this->bases.end(); ++_iter20)
      {
        xfer += (*_iter20).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorldState &a, WorldState &b) {
  using ::std::swap;
  swap(a.units, b.units);
  swap(a.bases, b.bases);
  swap(a.__isset, b.__isset);
}

const char* WeatherState::ascii_fingerprint = "75971A588272C97A80EBFD5BA7E9F503";
const uint8_t WeatherState::binary_fingerprint[16] = {0x75,0x97,0x1A,0x58,0x82,0x72,0xC9,0x7A,0x80,0xEB,0xFD,0x5B,0xA7,0xE9,0xF5,0x03};

uint32_t WeatherState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->condition = (WeatherCond::type)ecast21;
          this->__isset.condition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->turn);
          this->__isset.turn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WeatherState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WeatherState");

  if (this->__isset.condition) {
    xfer += oprot->writeFieldBegin("condition", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->condition);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.turn) {
    xfer += oprot->writeFieldBegin("turn", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->turn);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WeatherState &a, WeatherState &b) {
  using ::std::swap;
  swap(a.condition, b.condition);
  swap(a.turn, b.turn);
  swap(a.__isset, b.__isset);
}

const char* UserState::ascii_fingerprint = "06627DF28001C5F7C9FEADD786C258F7";
const uint8_t UserState::binary_fingerprint[16] = {0x06,0x62,0x7D,0xF2,0x80,0x01,0xC5,0xF7,0xC9,0xFE,0xAD,0xD7,0x86,0xC2,0x58,0xF7};

uint32_t UserState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queueLen);
          this->__isset.queueLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastValidOps);
          this->__isset.lastValidOps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastInvalidOps);
          this->__isset.lastInvalidOps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->weather.read(iprot);
          this->__isset.weather = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UserState");

  if (this->__isset.queueLen) {
    xfer += oprot->writeFieldBegin("queueLen", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->queueLen);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastValidOps) {
    xfer += oprot->writeFieldBegin("lastValidOps", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->lastValidOps);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastInvalidOps) {
    xfer += oprot->writeFieldBegin("lastInvalidOps", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->lastInvalidOps);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gold) {
    xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->gold);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.weather) {
    xfer += oprot->writeFieldBegin("weather", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->weather.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserState &a, UserState &b) {
  using ::std::swap;
  swap(a.queueLen, b.queueLen);
  swap(a.lastValidOps, b.lastValidOps);
  swap(a.lastInvalidOps, b.lastInvalidOps);
  swap(a.gold, b.gold);
  swap(a.weather, b.weather);
  swap(a.__isset, b.__isset);
}

const char* State::ascii_fingerprint = "0EC1A936C39564CDC2AA83136CECF9EB";
const uint8_t State::binary_fingerprint[16] = {0x0E,0xC1,0xA9,0x36,0xC3,0x95,0x64,0xCD,0xC2,0xAA,0x83,0x13,0x6C,0xEC,0xF9,0xEB};

uint32_t State::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->world.read(iprot);
          this->__isset.world = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->turnNum);
          this->__isset.turnNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->user.read(iprot);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hasLost.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->hasLost.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readBool(this->hasLost[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hasLost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->itsOn);
          this->__isset.itsOn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t State::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("State");

  if (this->__isset.world) {
    xfer += oprot->writeFieldBegin("world", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->world.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.turnNum) {
    xfer += oprot->writeFieldBegin("turnNum", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->turnNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user) {
    xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->user.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hasLost) {
    xfer += oprot->writeFieldBegin("hasLost", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->hasLost.size()));
      std::vector<bool> ::const_iterator _iter27;
      for (_iter27 = this->hasLost.begin(); _iter27 != this->hasLost.end(); ++_iter27)
      {
        xfer += oprot->writeBool((*_iter27));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.itsOn) {
    xfer += oprot->writeFieldBegin("itsOn", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->itsOn);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(State &a, State &b) {
  using ::std::swap;
  swap(a.world, b.world);
  swap(a.turnNum, b.turnNum);
  swap(a.user, b.user);
  swap(a.hasLost, b.hasLost);
  swap(a.itsOn, b.itsOn);
  swap(a.__isset, b.__isset);
}

const char* GameMap::ascii_fingerprint = "DE4291DD16FC9A2ABBC51CF1C50A6C36";
const uint8_t GameMap::binary_fingerprint[16] = {0xDE,0x42,0x91,0xDD,0x16,0xFC,0x9A,0x2A,0xBB,0xC5,0x1C,0xF1,0xC5,0x0A,0x6C,0x36};

uint32_t GameMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tiles.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->tiles.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              {
                this->tiles[_i32].clear();
                uint32_t _size33;
                ::apache::thrift::protocol::TType _etype36;
                xfer += iprot->readListBegin(_etype36, _size33);
                this->tiles[_i32].resize(_size33);
                uint32_t _i37;
                for (_i37 = 0; _i37 < _size33; ++_i37)
                {
                  int32_t ecast38;
                  xfer += iprot->readI32(ecast38);
                  this->tiles[_i32][_i37] = (TileType::type)ecast38;
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->occupied.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->occupied.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              {
                this->occupied[_i43].clear();
                uint32_t _size44;
                ::apache::thrift::protocol::TType _etype47;
                xfer += iprot->readListBegin(_etype47, _size44);
                this->occupied[_i43].resize(_size44);
                uint32_t _i48;
                for (_i48 = 0; _i48 < _size44; ++_i48)
                {
                  xfer += iprot->readBool(this->occupied[_i43][_i48]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.occupied = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GameMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GameMap");

  if (this->__isset.tiles) {
    xfer += oprot->writeFieldBegin("tiles", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->tiles.size()));
      std::vector<std::vector<TileType::type> > ::const_iterator _iter49;
      for (_iter49 = this->tiles.begin(); _iter49 != this->tiles.end(); ++_iter49)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter49).size()));
          std::vector<TileType::type> ::const_iterator _iter50;
          for (_iter50 = (*_iter49).begin(); _iter50 != (*_iter49).end(); ++_iter50)
          {
            xfer += oprot->writeI32((int32_t)(*_iter50));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.occupied) {
    xfer += oprot->writeFieldBegin("occupied", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->occupied.size()));
      std::vector<std::vector<bool> > ::const_iterator _iter51;
      for (_iter51 = this->occupied.begin(); _iter51 != this->occupied.end(); ++_iter51)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*_iter51).size()));
          std::vector<bool> ::const_iterator _iter52;
          for (_iter52 = (*_iter51).begin(); _iter52 != (*_iter51).end(); ++_iter52)
          {
            xfer += oprot->writeBool((*_iter52));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.height) {
    xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->height);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.width) {
    xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->width);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GameMap &a, GameMap &b) {
  using ::std::swap;
  swap(a.tiles, b.tiles);
  swap(a.occupied, b.occupied);
  swap(a.height, b.height);
  swap(a.width, b.width);
  swap(a.__isset, b.__isset);
}

const char* InitialGame::ascii_fingerprint = "905D3458AB58DD6F684E84411023D83E";
const uint8_t InitialGame::binary_fingerprint[16] = {0x90,0x5D,0x34,0x58,0xAB,0x58,0xDD,0x6F,0x68,0x4E,0x84,0x41,0x10,0x23,0xD8,0x3E};

uint32_t InitialGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tok);
          this->__isset.tok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->state.read(iprot);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gameMap.read(iprot);
          this->__isset.gameMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InitialGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("InitialGame");

  if (this->__isset.tok) {
    xfer += oprot->writeFieldBegin("tok", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->tok);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->state.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pid) {
    xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gameMap) {
    xfer += oprot->writeFieldBegin("gameMap", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->gameMap.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitialGame &a, InitialGame &b) {
  using ::std::swap;
  swap(a.tok, b.tok);
  swap(a.state, b.state);
  swap(a.pid, b.pid);
  swap(a.gameMap, b.gameMap);
  swap(a.__isset, b.__isset);
}

const char* MoveOp::ascii_fingerprint = "6E2635070F69FED69A7EF528C76781C7";
const uint8_t MoveOp::binary_fingerprint[16] = {0x6E,0x26,0x35,0x07,0x0F,0x69,0xFE,0xD6,0x9A,0x7E,0xF5,0x28,0xC7,0x67,0x81,0xC7};

uint32_t MoveOp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unit.read(iprot);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->destination.read(iprot);
          this->__isset.destination = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MoveOp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MoveOp");

  if (this->__isset.unit) {
    xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->unit.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.destination) {
    xfer += oprot->writeFieldBegin("destination", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->destination.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MoveOp &a, MoveOp &b) {
  using ::std::swap;
  swap(a.unit, b.unit);
  swap(a.destination, b.destination);
  swap(a.__isset, b.__isset);
}

const char* AttackOp::ascii_fingerprint = "339ECDFED1577414E7CECA45E2287910";
const uint8_t AttackOp::binary_fingerprint[16] = {0x33,0x9E,0xCD,0xFE,0xD1,0x57,0x74,0x14,0xE7,0xCE,0xCA,0x45,0xE2,0x28,0x79,0x10};

uint32_t AttackOp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attacker.read(iprot);
          this->__isset.attacker = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->enemy.read(iprot);
          this->__isset.enemy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AttackOp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AttackOp");

  if (this->__isset.attacker) {
    xfer += oprot->writeFieldBegin("attacker", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->attacker.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enemy) {
    xfer += oprot->writeFieldBegin("enemy", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->enemy.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AttackOp &a, AttackOp &b) {
  using ::std::swap;
  swap(a.attacker, b.attacker);
  swap(a.enemy, b.enemy);
  swap(a.__isset, b.__isset);
}

const char* BuyOp::ascii_fingerprint = "275AD736456F20EBB896774FE6B08B81";
const uint8_t BuyOp::binary_fingerprint[16] = {0x27,0x5A,0xD7,0x36,0x45,0x6F,0x20,0xEB,0xB8,0x96,0x77,0x4F,0xE6,0xB0,0x8B,0x81};

uint32_t BuyOp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast53;
          xfer += iprot->readI32(ecast53);
          this->type = (UnitType::type)ecast53;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->startPos.read(iprot);
          this->__isset.startPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuyOp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BuyOp");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startPos) {
    xfer += oprot->writeFieldBegin("startPos", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->startPos.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuyOp &a, BuyOp &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.startPos, b.startPos);
  swap(a.__isset, b.__isset);
}

const char* Op::ascii_fingerprint = "0931A7E723602E5F931A1B48E7C4AAD1";
const uint8_t Op::binary_fingerprint[16] = {0x09,0x31,0xA7,0xE7,0x23,0x60,0x2E,0x5F,0x93,0x1A,0x1B,0x48,0xE7,0xC4,0xAA,0xD1};

uint32_t Op::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->type = (OpType::type)ecast54;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->move.read(iprot);
          this->__isset.move = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attack.read(iprot);
          this->__isset.attack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->buy.read(iprot);
          this->__isset.buy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Op::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Op");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.move) {
    xfer += oprot->writeFieldBegin("move", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->move.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attack) {
    xfer += oprot->writeFieldBegin("attack", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->attack.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.buy) {
    xfer += oprot->writeFieldBegin("buy", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->buy.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Op &a, Op &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.move, b.move);
  swap(a.attack, b.attack);
  swap(a.buy, b.buy);
  swap(a.__isset, b.__isset);
}

} // namespace
